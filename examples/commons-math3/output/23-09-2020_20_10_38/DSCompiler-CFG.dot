digraph DSCompiler_CFG {
  // graph-vertices
  v1  [label="162:  DSCompiler (final int parameters, final int order,  final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)"];
  v2  [label="166:  this.parameters = parameters"];
  v3  [label="167:  this.order  = order"];
  v4  [label="168:  this.sizes  = compileSizes(parameters, order, valueCompiler)"];
  v5  [label="169:  this.derivativesIndirection = compileDerivativesIndirection(parameters, order, valueCompiler, derivativeCompiler)"];
  v6  [label="172:  this.lowerIndirection = compileLowerIndirection(parameters, order, valueCompiler, derivativeCompiler)"];
  v7  [label="175:  this.multIndirection = compileMultiplicationIndirection(parameters, order,  valueCompiler, derivativeCompiler, lowerIndirection)"];
  v8  [label="178:  this.compIndirection = compileCompositionIndirection(parameters, order, valueCompiler, derivativeCompiler, sizes, derivativesIndirection)"];
  v9  [label="191:  DSCompiler getCompiler(int parameters, int order)"];
  v10  [label="195:  final DSCompiler[][] cache = compilers.get()"];
  v11  [label="196:  if (cache != null && cache.length > parameters && cache[parameters].length > order && cache[parameters][order] != null)"];
  v12  [label="199:  return cache[parameters][order];"];
  v13  [label="endif"];
  v14  [label="203:  final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length)"];
  v15  [label="204:  final int maxOrder  = FastMath.max(order, cache == null ? 0 : cache[0].length)"];
  v16  [label="205:  final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1]"];
  v17  [label="207:  if (cache != null)"];
  v18  [label="209:  for (  int i = 0 ; i < cache.length ;   ++i)"];
  v21  [label="endfor"];
  v22  [label="210:  System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length)"];
  v23  [label="endif"];
  v24  [label="215:  for (  int diag = 0 ; diag <= parameters + order ;   ++diag)"];
  v27  [label="endfor"];
  v28  [label="216:  for (  int o = FastMath.max(0, diag - parameters ;   ++o) ; o <= FastMath.min(  int o = FastMath.max(0, diag - parameters ;   ++o) ; order, diag ;   ++o) ;   ++o)"];
  v31  [label="endfor"];
  v32  [label="217:  final int p = diag - o"];
  v33  [label="218:  if (newCache[p][o] == null)"];
  v34  [label="219:  final DSCompiler valueCompiler  = (p == 0) ? null : newCache[p - 1][o]"];
  v35  [label="220:  final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1]"];
  v36  [label="221:  newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler)"];
  v37  [label="endif"];
  v38  [label="227:  compilers.compareAndSet(cache, newCache)"];
  v39  [label="229:  return newCache[parameters][order];"];
  v40  [label="239:  int[][] compileSizes(final int parameters, final int order, final DSCompiler valueCompiler)"];
  v41  [label="242:  final int[][] sizes = new int[parameters + 1][order + 1]"];
  v42  [label="243:  if (parameters == 0)"];
  v43  [label="244:  Arrays.fill(sizes[0], 1)"];
  v44  [label="endif"];
  v45  [label="246:  System.arraycopy(valueCompiler.sizes, 0, sizes, 0, parameters)"];
  v46  [label="247:  sizes[parameters][0] = 1"];
  v47  [label="248:  for (  int i = 0 ; i < order ;   ++i)"];
  v50  [label="endfor"];
  v51  [label="249:  sizes[parameters][i + 1] = sizes[parameters][i] + sizes[parameters - 1][i + 1]"];
  v52  [label="253:  return sizes;"];
  v53  [label="264:  int[][] compileDerivativesIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)"];
  v54  [label="268:  if (parameters == 0 || order == 0)"];
  v55  [label="269:  return new int[1][parameters];"];
  v56  [label="endif"];
  v57  [label="272:  final int vSize = valueCompiler.derivativesIndirection.length"];
  v58  [label="273:  final int dSize = derivativeCompiler.derivativesIndirection.length"];
  v59  [label="274:  final int[][] derivativesIndirection = new int[vSize + dSize][parameters]"];
  v60  [label="277:  for (  int i = 0 ; i < vSize ;   ++i)"];
  v63  [label="endfor"];
  v64  [label="279:  System.arraycopy(valueCompiler.derivativesIndirection[i], 0,  derivativesIndirection[i], 0,  parameters - 1)"];
  v65  [label="285:  for (  int i = 0 ; i < dSize ;   ++i)"];
  v68  [label="endfor"];
  v69  [label="288:  System.arraycopy(derivativeCompiler.derivativesIndirection[i], 0,  derivativesIndirection[vSize + i], 0,  parameters)"];
  v70  [label="293:  derivativesIndirection[vSize + i][parameters - 1]++"];
  v71  [label="297:  return derivativesIndirection;"];
  v72  [label="312:  int[] compileLowerIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)"];
  v73  [label="316:  if (parameters == 0 || order <= 1)"];
  v74  [label="317:  return new int[] { 0 };"];
  v75  [label="endif"];
  v76  [label="321:  final int vSize = valueCompiler.lowerIndirection.length"];
  v77  [label="322:  final int dSize = derivativeCompiler.lowerIndirection.length"];
  v78  [label="323:  final int[] lowerIndirection = new int[vSize + dSize]"];
  v79  [label="324:  System.arraycopy(valueCompiler.lowerIndirection, 0, lowerIndirection, 0, vSize)"];
  v80  [label="325:  for (  int i = 0 ; i < dSize ;   ++i)"];
  v83  [label="endfor"];
  v84  [label="326:  lowerIndirection[vSize + i] = valueCompiler.getSize() + derivativeCompiler.lowerIndirection[i]"];
  v85  [label="329:  return lowerIndirection;"];
  v86  [label="346:  int[][][] compileMultiplicationIndirection(final int parameters, final int order,  final DSCompiler valueCompiler,  final DSCompiler derivativeCompiler,  final int[] lowerIndirection)"];
  v87  [label="351:  if ((parameters == 0) || (order == 0))"];
  v88  [label="352:  return new int[][][] { { { 1, 0, 0 } } };"];
  v89  [label="endif"];
  v90  [label="356:  final int vSize = valueCompiler.multIndirection.length"];
  v91  [label="357:  final int dSize = derivativeCompiler.multIndirection.length"];
  v92  [label="358:  final int[][][] multIndirection = new int[vSize + dSize][][]"];
  v93  [label="360:  System.arraycopy(valueCompiler.multIndirection, 0, multIndirection, 0, vSize)"];
  v94  [label="362:  for (  int i = 0 ; i < dSize ;   ++i)"];
  v97  [label="endfor"];
  v98  [label="363:  final int[][] dRow = derivativeCompiler.multIndirection[i]"];
  v99  [label="364:  List<int[]> row = new ArrayList<int[]>(dRow.length * 2)"];
  v100  [label="365:  for (  int j = 0 ; j < dRow.length ;   ++j)"];
  v103  [label="endfor"];
  v104  [label="366:  row.add(new int[] { dRow[j][0], lowerIndirection[dRow[j][1]], vSize + dRow[j][2] })"];
  v105  [label="367:  row.add(new int[] { dRow[j][0], vSize + dRow[j][1], lowerIndirection[dRow[j][2]] })"];
  v106  [label="371:  final List<int[]> combined = new ArrayList<int[]>(row.size())"];
  v107  [label="372:  for (  int j = 0 ; j < row.size(  int j = 0 ;  ;   ++j) ;   ++j)"];
  v110  [label="endfor"];
  v111  [label="373:  final int[] termJ = row.get(j)"];
  v112  [label="374:  if (termJ[0] > 0)"];
  v113  [label="375:  for (  int k = j + 1 ; k < row.size(  int k = j + 1 ;  ;   ++k) ;   ++k)"];
  v116  [label="endfor"];
  v117  [label="376:  final int[] termK = row.get(k)"];
  v118  [label="377:  if (termJ[1] == termK[1] && termJ[2] == termK[2])"];
  v119  [label="379:  termJ[0] += termK[0]"];
  v120  [label="381:  termK[0] = 0"];
  v121  [label="endif"];
  v122  [label="384:  combined.add(termJ)"];
  v123  [label="endif"];
  v124  [label="388:  multIndirection[vSize + i] = combined.toArray(new int[combined.size()][])"];
  v125  [label="392:  return multIndirection;"];
  v126  [label="411:  int[][][] compileCompositionIndirection(final int parameters, final int order,  final DSCompiler valueCompiler,  final DSCompiler derivativeCompiler,  final int[][] sizes,  final int[][] derivativesIndirection)"];
  v127  [label="418:  if ((parameters == 0) || (order == 0))"];
  v128  [label="419:  return new int[][][] { { { 1, 0 } } };"];
  v129  [label="endif"];
  v130  [label="422:  final int vSize = valueCompiler.compIndirection.length"];
  v131  [label="423:  final int dSize = derivativeCompiler.compIndirection.length"];
  v132  [label="424:  final int[][][] compIndirection = new int[vSize + dSize][][]"];
  v133  [label="427:  System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize)"];
  v134  [label="433:  for (  int i = 0 ; i < dSize ;   ++i)"];
  v137  [label="endfor"];
  v138  [label="434:  List<int[]> row = new ArrayList<int[]>()"];
  v139  [label="435:  for (int[] term : derivativeCompiler.compIndirection[i])"];
  v140  [label="endfor"];
  v141  [label="440:  int[] derivedTermF = new int[term.length + 1]"];
  v142  [label="441:  derivedTermF[0] = term[0]"];
  v143  [label="442:  derivedTermF[1] = term[1] + 1"];
  v144  [label="443:  int[] orders = new int[parameters]"];
  v145  [label="444:  orders[parameters - 1] = 1"];
  v146  [label="445:  derivedTermF[term.length] = getPartialDerivativeIndex(parameters, order, sizes, orders)"];
  v147  [label="446:  for (  int j = 2 ; j < term.length ;   ++j)"];
  v150  [label="endfor"];
  v151  [label="449:  derivedTermF[j] = convertIndex(term[j], parameters,  derivativeCompiler.derivativesIndirection,  parameters, order, sizes)"];
  v152  [label="453:  Arrays.sort(derivedTermF, 2, derivedTermF.length)"];
  v153  [label="454:  row.add(derivedTermF)"];
  v154  [label="457:  for (  int l = 2 ; l < term.length ;   ++l)"];
  v157  [label="endfor"];
  v158  [label="458:  int[] derivedTermG = new int[term.length]"];
  v159  [label="459:  derivedTermG[0] = term[0]"];
  v160  [label="460:  derivedTermG[1] = term[1]"];
  v161  [label="461:  for (  int j = 2 ; j < term.length ;   ++j)"];
  v164  [label="endfor"];
  v165  [label="464:  derivedTermG[j] = convertIndex(term[j], parameters,  derivativeCompiler.derivativesIndirection,  parameters, order, sizes)"];
  v166  [label="467:  if (j == l)"];
  v167  [label="469:  System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters)"];
  v168  [label="470:  orders[parameters - 1]++"];
  v169  [label="471:  derivedTermG[j] = getPartialDerivativeIndex(parameters, order, sizes, orders)"];
  v170  [label="endif"];
  v171  [label="474:  Arrays.sort(derivedTermG, 2, derivedTermG.length)"];
  v172  [label="475:  row.add(derivedTermG)"];
  v173  [label="481:  final List<int[]> combined = new ArrayList<int[]>(row.size())"];
  v174  [label="482:  for (  int j = 0 ; j < row.size(  int j = 0 ;  ;   ++j) ;   ++j)"];
  v177  [label="endfor"];
  v178  [label="483:  final int[] termJ = row.get(j)"];
  v179  [label="484:  if (termJ[0] > 0)"];
  v180  [label="485:  for (  int k = j + 1 ; k < row.size(  int k = j + 1 ;  ;   ++k) ;   ++k)"];
  v183  [label="endfor"];
  v184  [label="486:  final int[] termK = row.get(k)"];
  v185  [label="487:  boolean equals = termJ.length == termK.length"];
  v186  [label="488:  for (  int l = 1 ; equals && l < termJ.length ;   ++l)"];
  v189  [label="endfor"];
  v190  [label="489:  equals &= termJ[l] == termK[l]"];
  v191  [label="491:  if (equals)"];
  v192  [label="493:  termJ[0] += termK[0]"];
  v193  [label="495:  termK[0] = 0"];
  v194  [label="endif"];
  v195  [label="498:  combined.add(termJ)"];
  v196  [label="endif"];
  v197  [label="502:  compIndirection[vSize + i] = combined.toArray(new int[combined.size()][])"];
  v198  [label="506:  return compIndirection;"];
  v199  [label="542:  int getPartialDerivativeIndex(final int ... orders)"];
  v200  [label="546:  if (orders.length != getFreeParameters())"];
  v201  [label="547:  throw new DimensionMismatchException(orders.length, getFreeParameters())"];
  v202  [label="endif"];
  v203  [label="550:  return getPartialDerivativeIndex(parameters, order, sizes, orders);"];
  v204  [label="564:  int getPartialDerivativeIndex(final int parameters, final int order,  final int[][] sizes, final int ... orders)"];
  v205  [label="570:  int index = 0"];
  v206  [label="571:  int m = order"];
  v207  [label="572:  int ordersSum = 0"];
  v208  [label="573:  for (  int i = parameters - 1 ; i >= 0 ;   --i)"];
  v211  [label="endfor"];
  v212  [label="576:  int derivativeOrder = orders[i]"];
  v213  [label="579:  ordersSum += derivativeOrder"];
  v214  [label="580:  if (ordersSum > order)"];
  v215  [label="581:  throw new NumberIsTooLargeException(ordersSum, order, true)"];
  v216  [label="endif"];
  v217  [label="584:  while (derivativeOrder-- > 0)"];
  v218  [label="endwhile"];
  v219  [label="588:  index += sizes[i][m--]"];
  v220  [label="593:  return index;"];
  v221  [label="609:  int convertIndex(final int index, final int srcP, final int[][] srcDerivativesIndirection, final int destP, final int destO, final int[][] destSizes)"];
  v222  [label="613:  int[] orders = new int[destP]"];
  v223  [label="614:  System.arraycopy(srcDerivativesIndirection[index], 0, orders, 0, FastMath.min(srcP, destP))"];
  v224  [label="615:  return getPartialDerivativeIndex(destP, destO, destSizes, orders);"];
  v225  [label="626:  int[] getPartialDerivativeOrders(final int index)"];
  v226  [label="627:  return derivativesIndirection[index];"];
  v227  [label="633:  int getFreeParameters()"];
  v228  [label="634:  return parameters;"];
  v229  [label="640:  int getOrder()"];
  v230  [label="641:  return order;"];
  v231  [label="651:  int getSize()"];
  v232  [label="652:  return sizes[parameters][order];"];
  v233  [label="667:  void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double[] result, final int resultOffset)"];
  v234  [label="670:  for (  int i = 0 ; i < getSize(  int i = 0 ;  ;   ++i) ;   ++i)"];
  v237  [label="endfor"];
  v238  [label="671:  result[resultOffset + i] = MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i])"];
  v239  [label="691:  void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double[] result, final int resultOffset)"];
  v240  [label="695:  for (  int i = 0 ; i < getSize(  int i = 0 ;  ;   ++i) ;   ++i)"];
  v243  [label="endfor"];
  v244  [label="696:  result[resultOffset + i] = MathArrays.linearCombination(a1, c1[offset1 + i],  a2, c2[offset2 + i],  a3, c3[offset3 + i])"];
  v245  [label="721:  void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double a4, final double[] c4, final int offset4, final double[] result, final int resultOffset)"];
  v246  [label="726:  for (  int i = 0 ; i < getSize(  int i = 0 ;  ;   ++i) ;   ++i)"];
  v249  [label="endfor"];
  v250  [label="727:  result[resultOffset + i] = MathArrays.linearCombination(a1, c1[offset1 + i],  a2, c2[offset2 + i],  a3, c3[offset3 + i],  a4, c4[offset4 + i])"];
  v251  [label="744:  void add(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)"];
  v252  [label="747:  for (  int i = 0 ; i < getSize(  int i = 0 ;  ;   ++i) ;   ++i)"];
  v255  [label="endfor"];
  v256  [label="748:  result[resultOffset + i] = lhs[lhsOffset + i] + rhs[rhsOffset + i]"];
  v257  [label="760:  void subtract(final double[] lhs, final int lhsOffset,  final double[] rhs, final int rhsOffset,  final double[] result, final int resultOffset)"];
  v258  [label="763:  for (  int i = 0 ; i < getSize(  int i = 0 ;  ;   ++i) ;   ++i)"];
  v261  [label="endfor"];
  v262  [label="764:  result[resultOffset + i] = lhs[lhsOffset + i] - rhs[rhsOffset + i]"];
  v263  [label="778:  void multiply(final double[] lhs, final int lhsOffset,  final double[] rhs, final int rhsOffset,  final double[] result, final int resultOffset)"];
  v264  [label="781:  for (  int i = 0 ; i < multIndirection.length ;   ++i)"];
  v267  [label="endfor"];
  v268  [label="782:  final int[][] mappingI = multIndirection[i]"];
  v269  [label="783:  double r = 0"];
  v270  [label="784:  for (  int j = 0 ; j < mappingI.length ;   ++j)"];
  v273  [label="endfor"];
  v274  [label="785:  r += mappingI[j][0] *  lhs[lhsOffset + mappingI[j][1]] *  rhs[rhsOffset + mappingI[j][2]]"];
  v275  [label="789:  result[resultOffset + i] = r"];
  v276  [label="803:  void divide(final double[] lhs, final int lhsOffset,  final double[] rhs, final int rhsOffset,  final double[] result, final int resultOffset)"];
  v277  [label="806:  final double[] reciprocal = new double[getSize()]"];
  v278  [label="807:  pow(rhs, lhsOffset, -1, reciprocal, 0)"];
  v279  [label="808:  multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset)"];
  v280  [label="820:  void remainder(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset)"];
  v281  [label="825:  final double rem = FastMath.IEEEremainder(lhs[lhsOffset], rhs[rhsOffset])"];
  v282  [label="826:  final double k = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset])"];
  v283  [label="829:  result[resultOffset] = rem"];
  v284  [label="832:  for (  int i = 1 ; i < getSize(  int i = 1 ;  ;   ++i) ;   ++i)"];
  v287  [label="endfor"];
  v288  [label="833:  result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i]"];
  v289  [label="848:  void pow(final double a, final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v290  [label="854:  final double[] function = new double[1 + order]"];
  v291  [label="855:  if (a == 0)"];
  v292  [label="856:  if (operand[operandOffset] == 0)"];
  v293  [label="857:  function[0] = 1"];
  v294  [label="858:  double infinity = Double.POSITIVE_INFINITY"];
  v295  [label="859:  for (  int i = 1 ; i < function.length ;   ++i)"];
  v298  [label="endfor"];
  v299  [label="860:  infinity = -infinity"];
  v300  [label="861:  function[i] = infinity"];
  v301  [label="endif"];
  v302  [label="863:  if (operand[operandOffset] < 0)"];
  v303  [label="864:  Arrays.fill(function, Double.NaN)"];
  v304  [label="endif"];
  v305  [label="endif"];
  v306  [label="867:  function[0] = FastMath.pow(a, operand[operandOffset])"];
  v307  [label="868:  final double lnA = FastMath.log(a)"];
  v308  [label="869:  for (  int i = 1 ; i < function.length ;   ++i)"];
  v311  [label="endfor"];
  v312  [label="870:  function[i] = lnA * function[i - 1]"];
  v313  [label="876:  compose(operand, operandOffset, function, result, resultOffset)"];
  v314  [label="889:  void pow(final double[] operand, final int operandOffset, final double p, final double[] result, final int resultOffset)"];
  v315  [label="894:  double[] function = new double[1 + order]"];
  v316  [label="895:  double xk = FastMath.pow(operand[operandOffset], p - order)"];
  v317  [label="896:  for (  int i = order ; i > 0 ;   --i)"];
  v320  [label="endfor"];
  v321  [label="897:  function[i] = xk"];
  v322  [label="898:  xk *= operand[operandOffset]"];
  v323  [label="900:  function[0] = xk"];
  v324  [label="901:  double coefficient = p"];
  v325  [label="902:  for (  int i = 1 ; i <= order ;   ++i)"];
  v328  [label="endfor"];
  v329  [label="903:  function[i] *= coefficient"];
  v330  [label="904:  coefficient *= p - i"];
  v331  [label="908:  compose(operand, operandOffset, function, result, resultOffset)"];
  v332  [label="921:  void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset)"];
  v333  [label="924:  if (n == 0)"];
  v334  [label="926:  result[resultOffset] = 1.0"];
  v335  [label="927:  Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0)"];
  v336  [label="928:  return;"];
  v337  [label="endif"];
  v338  [label="933:  double[] function = new double[1 + order]"];
  v339  [label="935:  if (n > 0)"];
  v340  [label="937:  final int maxOrder = FastMath.min(order, n)"];
  v341  [label="938:  double xk = FastMath.pow(operand[operandOffset], n - maxOrder)"];
  v342  [label="939:  for (  int i = maxOrder ; i > 0 ;   --i)"];
  v345  [label="endfor"];
  v346  [label="940:  function[i] = xk"];
  v347  [label="941:  xk *= operand[operandOffset]"];
  v348  [label="943:  function[0] = xk"];
  v349  [label="endif"];
  v350  [label="946:  final double inv = 1.0 / operand[operandOffset]"];
  v351  [label="947:  double xk = FastMath.pow(inv, -n)"];
  v352  [label="948:  for (  int i = 0 ; i <= order ;   ++i)"];
  v355  [label="endfor"];
  v356  [label="949:  function[i] = xk"];
  v357  [label="950:  xk *= inv"];
  v358  [label="954:  double coefficient = n"];
  v359  [label="955:  for (  int i = 1 ; i <= order ;   ++i)"];
  v362  [label="endfor"];
  v363  [label="956:  function[i] *= coefficient"];
  v364  [label="957:  coefficient *= n - i"];
  v365  [label="961:  compose(operand, operandOffset, function, result, resultOffset)"];
  v366  [label="975:  void pow(final double[] x, final int xOffset, final double[] y, final int yOffset, final double[] result, final int resultOffset)"];
  v367  [label="978:  final double[] logX = new double[getSize()]"];
  v368  [label="979:  log(x, xOffset, logX, 0)"];
  v369  [label="980:  final double[] yLogX = new double[getSize()]"];
  v370  [label="981:  multiply(logX, 0, y, yOffset, yLogX, 0)"];
  v371  [label="982:  exp(yLogX, 0, result, resultOffset)"];
  v372  [label="994:  void rootN(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset)"];
  v373  [label="999:  double[] function = new double[1 + order]"];
  v374  [label="1000:  double xk"];
  v375  [label="1001:  if (n == 2)"];
  v376  [label="1002:  function[0] = FastMath.sqrt(operand[operandOffset])"];
  v377  [label="1003:  xk  = 0.5 / function[0]"];
  v378  [label="endif"];
  v379  [label="1004:  if (n == 3)"];
  v380  [label="1005:  function[0] = FastMath.cbrt(operand[operandOffset])"];
  v381  [label="1006:  xk  = 1.0 / (3.0 * function[0] * function[0])"];
  v382  [label="endif"];
  v383  [label="1008:  function[0] = FastMath.pow(operand[operandOffset], 1.0 / n)"];
  v384  [label="1009:  xk  = 1.0 / (n * FastMath.pow(function[0], n - 1))"];
  v385  [label="1011:  final double nReciprocal = 1.0 / n"];
  v386  [label="1012:  final double xReciprocal = 1.0 / operand[operandOffset]"];
  v387  [label="1013:  for (  int i = 1 ; i <= order ;   ++i)"];
  v390  [label="endfor"];
  v391  [label="1014:  function[i] = xk"];
  v392  [label="1015:  xk *= xReciprocal * (nReciprocal - i)"];
  v393  [label="1019:  compose(operand, operandOffset, function, result, resultOffset)"];
  v394  [label="1031:  void exp(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v395  [label="1035:  double[] function = new double[1 + order]"];
  v396  [label="1036:  Arrays.fill(function, FastMath.exp(operand[operandOffset]))"];
  v397  [label="1039:  compose(operand, operandOffset, function, result, resultOffset)"];
  v398  [label="1051:  void expm1(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v399  [label="1055:  double[] function = new double[1 + order]"];
  v400  [label="1056:  function[0] = FastMath.expm1(operand[operandOffset])"];
  v401  [label="1057:  Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]))"];
  v402  [label="1060:  compose(operand, operandOffset, function, result, resultOffset)"];
  v403  [label="1072:  void log(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v404  [label="1076:  double[] function = new double[1 + order]"];
  v405  [label="1077:  function[0] = FastMath.log(operand[operandOffset])"];
  v406  [label="1078:  if (order > 0)"];
  v407  [label="1079:  double inv = 1.0 / operand[operandOffset]"];
  v408  [label="1080:  double xk  = inv"];
  v409  [label="1081:  for (  int i = 1 ; i <= order ;   ++i)"];
  v412  [label="endfor"];
  v413  [label="1082:  function[i] = xk"];
  v414  [label="1083:  xk *= -i * inv"];
  v415  [label="endif"];
  v416  [label="1088:  compose(operand, operandOffset, function, result, resultOffset)"];
  v417  [label="1099:  void log1p(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v418  [label="1103:  double[] function = new double[1 + order]"];
  v419  [label="1104:  function[0] = FastMath.log1p(operand[operandOffset])"];
  v420  [label="1105:  if (order > 0)"];
  v421  [label="1106:  double inv = 1.0 / (1.0 + operand[operandOffset])"];
  v422  [label="1107:  double xk  = inv"];
  v423  [label="1108:  for (  int i = 1 ; i <= order ;   ++i)"];
  v426  [label="endfor"];
  v427  [label="1109:  function[i] = xk"];
  v428  [label="1110:  xk *= -i * inv"];
  v429  [label="endif"];
  v430  [label="1115:  compose(operand, operandOffset, function, result, resultOffset)"];
  v431  [label="1126:  void log10(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v432  [label="1130:  double[] function = new double[1 + order]"];
  v433  [label="1131:  function[0] = FastMath.log10(operand[operandOffset])"];
  v434  [label="1132:  if (order > 0)"];
  v435  [label="1133:  double inv = 1.0 / operand[operandOffset]"];
  v436  [label="1134:  double xk  = inv / FastMath.log(10.0)"];
  v437  [label="1135:  for (  int i = 1 ; i <= order ;   ++i)"];
  v440  [label="endfor"];
  v441  [label="1136:  function[i] = xk"];
  v442  [label="1137:  xk *= -i * inv"];
  v443  [label="endif"];
  v444  [label="1142:  compose(operand, operandOffset, function, result, resultOffset)"];
  v445  [label="1154:  void cos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v446  [label="1158:  double[] function = new double[1 + order]"];
  v447  [label="1159:  function[0] = FastMath.cos(operand[operandOffset])"];
  v448  [label="1160:  if (order > 0)"];
  v449  [label="1161:  function[1] = -FastMath.sin(operand[operandOffset])"];
  v450  [label="1162:  for (  int i = 2 ; i <= order ;   ++i)"];
  v453  [label="endfor"];
  v454  [label="1163:  function[i] = -function[i - 2]"];
  v455  [label="endif"];
  v456  [label="1168:  compose(operand, operandOffset, function, result, resultOffset)"];
  v457  [label="1180:  void sin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v458  [label="1184:  double[] function = new double[1 + order]"];
  v459  [label="1185:  function[0] = FastMath.sin(operand[operandOffset])"];
  v460  [label="1186:  if (order > 0)"];
  v461  [label="1187:  function[1] = FastMath.cos(operand[operandOffset])"];
  v462  [label="1188:  for (  int i = 2 ; i <= order ;   ++i)"];
  v465  [label="endfor"];
  v466  [label="1189:  function[i] = -function[i - 2]"];
  v467  [label="endif"];
  v468  [label="1194:  compose(operand, operandOffset, function, result, resultOffset)"];
  v469  [label="1206:  void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v470  [label="1210:  final double[] function = new double[1 + order]"];
  v471  [label="1211:  final double t = FastMath.tan(operand[operandOffset])"];
  v472  [label="1212:  function[0] = t"];
  v473  [label="1214:  if (order > 0)"];
  v474  [label="1223:  final double[] p = new double[order + 2]"];
  v475  [label="1224:  p[1] = 1"];
  v476  [label="1225:  final double t2 = t * t"];
  v477  [label="1226:  for (  int n = 1 ; n <= order ;   ++n)"];
  v480  [label="endfor"];
  v481  [label="1229:  double v = 0"];
  v482  [label="1230:  p[n + 1] = n * p[n]"];
  v483  [label="1231:  for (  int k = n + 1 ; k >= 0 ;   k -= 2)"];
  v486  [label="endfor"];
  v487  [label="1232:  v = v * t2 + p[k]"];
  v488  [label="1233:  if (k > 2)"];
  v489  [label="1234:  p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3]"];
  v490  [label="endif"];
  v491  [label="1235:  if (k == 2)"];
  v492  [label="1236:  p[0] = p[1]"];
  v493  [label="endif"];
  v494  [label="1239:  if ((n & 0x1) == 0)"];
  v495  [label="1240:  v *= t"];
  v496  [label="endif"];
  v497  [label="1243:  function[n] = v"];
  v498  [label="endif"];
  v499  [label="1249:  compose(operand, operandOffset, function, result, resultOffset)"];
  v500  [label="1261:  void acos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v501  [label="1265:  double[] function = new double[1 + order]"];
  v502  [label="1266:  final double x = operand[operandOffset]"];
  v503  [label="1267:  function[0] = FastMath.acos(x)"];
  v504  [label="1268:  if (order > 0)"];
  v505  [label="1276:  final double[] p = new double[order]"];
  v506  [label="1277:  p[0] = -1"];
  v507  [label="1278:  final double x2  = x * x"];
  v508  [label="1279:  final double f = 1.0 / (1 - x2)"];
  v509  [label="1280:  double coeff = FastMath.sqrt(f)"];
  v510  [label="1281:  function[1] = coeff * p[0]"];
  v511  [label="1282:  for (  int n = 2 ; n <= order ;   ++n)"];
  v514  [label="endfor"];
  v515  [label="1285:  double v = 0"];
  v516  [label="1286:  p[n - 1] = (n - 1) * p[n - 2]"];
  v517  [label="1287:  for (  int k = n - 1 ; k >= 0 ;   k -= 2)"];
  v520  [label="endfor"];
  v521  [label="1288:  v = v * x2 + p[k]"];
  v522  [label="1289:  if (k > 2)"];
  v523  [label="1290:  p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3]"];
  v524  [label="endif"];
  v525  [label="1291:  if (k == 2)"];
  v526  [label="1292:  p[0] = p[1]"];
  v527  [label="endif"];
  v528  [label="1295:  if ((n & 0x1) == 0)"];
  v529  [label="1296:  v *= x"];
  v530  [label="endif"];
  v531  [label="1299:  coeff *= f"];
  v532  [label="1300:  function[n] = coeff * v"];
  v533  [label="endif"];
  v534  [label="1306:  compose(operand, operandOffset, function, result, resultOffset)"];
  v535  [label="1318:  void asin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v536  [label="1322:  double[] function = new double[1 + order]"];
  v537  [label="1323:  final double x = operand[operandOffset]"];
  v538  [label="1324:  function[0] = FastMath.asin(x)"];
  v539  [label="1325:  if (order > 0)"];
  v540  [label="1333:  final double[] p = new double[order]"];
  v541  [label="1334:  p[0] = 1"];
  v542  [label="1335:  final double x2  = x * x"];
  v543  [label="1336:  final double f = 1.0 / (1 - x2)"];
  v544  [label="1337:  double coeff = FastMath.sqrt(f)"];
  v545  [label="1338:  function[1] = coeff * p[0]"];
  v546  [label="1339:  for (  int n = 2 ; n <= order ;   ++n)"];
  v549  [label="endfor"];
  v550  [label="1342:  double v = 0"];
  v551  [label="1343:  p[n - 1] = (n - 1) * p[n - 2]"];
  v552  [label="1344:  for (  int k = n - 1 ; k >= 0 ;   k -= 2)"];
  v555  [label="endfor"];
  v556  [label="1345:  v = v * x2 + p[k]"];
  v557  [label="1346:  if (k > 2)"];
  v558  [label="1347:  p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3]"];
  v559  [label="endif"];
  v560  [label="1348:  if (k == 2)"];
  v561  [label="1349:  p[0] = p[1]"];
  v562  [label="endif"];
  v563  [label="1352:  if ((n & 0x1) == 0)"];
  v564  [label="1353:  v *= x"];
  v565  [label="endif"];
  v566  [label="1356:  coeff *= f"];
  v567  [label="1357:  function[n] = coeff * v"];
  v568  [label="endif"];
  v569  [label="1363:  compose(operand, operandOffset, function, result, resultOffset)"];
  v570  [label="1375:  void atan(final double[] operand, final int operandOffset,  final double[] result, final int resultOffset)"];
  v571  [label="1379:  double[] function = new double[1 + order]"];
  v572  [label="1380:  final double x = operand[operandOffset]"];
  v573  [label="1381:  function[0] = FastMath.atan(x)"];
  v574  [label="1382:  if (order > 0)"];
  v575  [label="1390:  final double[] q = new double[order]"];
  v576  [label="1391:  q[0] = 1"];
  v577  [label="1392:  final double x2  = x * x"];
  v578  [label="1393:  final double f = 1.0 / (1 + x2)"];
  v579  [label="1394:  double coeff = f"];
  v580  [label="1395:  function[1] = coeff * q[0]"];
  v581  [label="1396:  for (  int n = 2 ; n <= order ;   ++n)"];
  v584  [label="endfor"];
  v585  [label="1399:  double v = 0"];
  v586  [label="1400:  q[n - 1] = -n * q[n - 2]"];
  v587  [label="1401:  for (  int k = n - 1 ; k >= 0 ;   k -= 2)"];
  v590  [label="endfor"];
  v591  [label="1402:  v = v * x2 + q[k]"];
  v592  [label="1403:  if (k > 2)"];
  v593  [label="1404:  q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3]"];
  v594  [label="endif"];
  v595  [label="1405:  if (k == 2)"];
  v596  [label="1406:  q[0] = q[1]"];
  v597  [label="endif"];
  v598  [label="1409:  if ((n & 0x1) == 0)"];
  v599  [label="1410:  v *= x"];
  v600  [label="endif"];
  v601  [label="1413:  coeff *= f"];
  v602  [label="1414:  function[n] = coeff * v"];
  v603  [label="endif"];
  v604  [label="1420:  compose(operand, operandOffset, function, result, resultOffset)"];
  v605  [label="1434:  void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset)"];
  v606  [label="1439:  double[] tmp1 = new double[getSize()]"];
  v607  [label="1440:  multiply(x, xOffset, x, xOffset, tmp1, 0)"];
  v608  [label="1441:  double[] tmp2 = new double[getSize()]"];
  v609  [label="1442:  multiply(y, yOffset, y, yOffset, tmp2, 0)"];
  v610  [label="1443:  add(tmp1, 0, tmp2, 0, tmp2, 0)"];
  v611  [label="1444:  rootN(tmp2, 0, 2, tmp1, 0)"];
  v612  [label="1446:  if (x[xOffset] >= 0)"];
  v613  [label="1449:  add(tmp1, 0, x, xOffset, tmp2, 0)"];
  v614  [label="1450:  divide(y, yOffset, tmp2, 0, tmp1, 0)"];
  v615  [label="1451:  atan(tmp1, 0, tmp2, 0)"];
  v616  [label="1452:  for (  int i = 0 ; i < tmp2.length ;   ++i)"];
  v619  [label="endfor"];
  v620  [label="1453:  result[resultOffset + i] = 2 * tmp2[i]"];
  v621  [label="endif"];
  v622  [label="1459:  subtract(tmp1, 0, x, xOffset, tmp2, 0)"];
  v623  [label="1460:  divide(y, yOffset, tmp2, 0, tmp1, 0)"];
  v624  [label="1461:  atan(tmp1, 0, tmp2, 0)"];
  v625  [label="1462:  result[resultOffset] = ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]"];
  v626  [label="1464:  for (  int i = 1 ; i < tmp2.length ;   ++i)"];
  v629  [label="endfor"];
  v630  [label="1465:  result[resultOffset + i] = -2 * tmp2[i]"];
  v631  [label="1471:  result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset])"];
  v632  [label="1483:  void cosh(final double[] operand, final int operandOffset,  final double[] result, final int resultOffset)"];
  v633  [label="1487:  double[] function = new double[1 + order]"];
  v634  [label="1488:  function[0] = FastMath.cosh(operand[operandOffset])"];
  v635  [label="1489:  if (order > 0)"];
  v636  [label="1490:  function[1] = FastMath.sinh(operand[operandOffset])"];
  v637  [label="1491:  for (  int i = 2 ; i <= order ;   ++i)"];
  v640  [label="endfor"];
  v641  [label="1492:  function[i] = function[i - 2]"];
  v642  [label="endif"];
  v643  [label="1497:  compose(operand, operandOffset, function, result, resultOffset)"];
  v644  [label="1509:  void sinh(final double[] operand, final int operandOffset,  final double[] result, final int resultOffset)"];
  v645  [label="1513:  double[] function = new double[1 + order]"];
  v646  [label="1514:  function[0] = FastMath.sinh(operand[operandOffset])"];
  v647  [label="1515:  if (order > 0)"];
  v648  [label="1516:  function[1] = FastMath.cosh(operand[operandOffset])"];
  v649  [label="1517:  for (  int i = 2 ; i <= order ;   ++i)"];
  v652  [label="endfor"];
  v653  [label="1518:  function[i] = function[i - 2]"];
  v654  [label="endif"];
  v655  [label="1523:  compose(operand, operandOffset, function, result, resultOffset)"];
  v656  [label="1535:  void tanh(final double[] operand, final int operandOffset,  final double[] result, final int resultOffset)"];
  v657  [label="1539:  final double[] function = new double[1 + order]"];
  v658  [label="1540:  final double t = FastMath.tanh(operand[operandOffset])"];
  v659  [label="1541:  function[0] = t"];
  v660  [label="1543:  if (order > 0)"];
  v661  [label="1552:  final double[] p = new double[order + 2]"];
  v662  [label="1553:  p[1] = 1"];
  v663  [label="1554:  final double t2 = t * t"];
  v664  [label="1555:  for (  int n = 1 ; n <= order ;   ++n)"];
  v667  [label="endfor"];
  v668  [label="1558:  double v = 0"];
  v669  [label="1559:  p[n + 1] = -n * p[n]"];
  v670  [label="1560:  for (  int k = n + 1 ; k >= 0 ;   k -= 2)"];
  v673  [label="endfor"];
  v674  [label="1561:  v = v * t2 + p[k]"];
  v675  [label="1562:  if (k > 2)"];
  v676  [label="1563:  p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3]"];
  v677  [label="endif"];
  v678  [label="1564:  if (k == 2)"];
  v679  [label="1565:  p[0] = p[1]"];
  v680  [label="endif"];
  v681  [label="1568:  if ((n & 0x1) == 0)"];
  v682  [label="1569:  v *= t"];
  v683  [label="endif"];
  v684  [label="1572:  function[n] = v"];
  v685  [label="endif"];
  v686  [label="1578:  compose(operand, operandOffset, function, result, resultOffset)"];
  v687  [label="1590:  void acosh(final double[] operand, final int operandOffset,  final double[] result, final int resultOffset)"];
  v688  [label="1594:  double[] function = new double[1 + order]"];
  v689  [label="1595:  final double x = operand[operandOffset]"];
  v690  [label="1596:  function[0] = FastMath.acosh(x)"];
  v691  [label="1597:  if (order > 0)"];
  v692  [label="1605:  final double[] p = new double[order]"];
  v693  [label="1606:  p[0] = 1"];
  v694  [label="1607:  final double x2  = x * x"];
  v695  [label="1608:  final double f = 1.0 / (x2 - 1)"];
  v696  [label="1609:  double coeff = FastMath.sqrt(f)"];
  v697  [label="1610:  function[1] = coeff * p[0]"];
  v698  [label="1611:  for (  int n = 2 ; n <= order ;   ++n)"];
  v701  [label="endfor"];
  v702  [label="1614:  double v = 0"];
  v703  [label="1615:  p[n - 1] = (1 - n) * p[n - 2]"];
  v704  [label="1616:  for (  int k = n - 1 ; k >= 0 ;   k -= 2)"];
  v707  [label="endfor"];
  v708  [label="1617:  v = v * x2 + p[k]"];
  v709  [label="1618:  if (k > 2)"];
  v710  [label="1619:  p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3]"];
  v711  [label="endif"];
  v712  [label="1620:  if (k == 2)"];
  v713  [label="1621:  p[0] = -p[1]"];
  v714  [label="endif"];
  v715  [label="1624:  if ((n & 0x1) == 0)"];
  v716  [label="1625:  v *= x"];
  v717  [label="endif"];
  v718  [label="1628:  coeff *= f"];
  v719  [label="1629:  function[n] = coeff * v"];
  v720  [label="endif"];
  v721  [label="1635:  compose(operand, operandOffset, function, result, resultOffset)"];
  v722  [label="1647:  void asinh(final double[] operand, final int operandOffset,  final double[] result, final int resultOffset)"];
  v723  [label="1651:  double[] function = new double[1 + order]"];
  v724  [label="1652:  final double x = operand[operandOffset]"];
  v725  [label="1653:  function[0] = FastMath.asinh(x)"];
  v726  [label="1654:  if (order > 0)"];
  v727  [label="1662:  final double[] p = new double[order]"];
  v728  [label="1663:  p[0] = 1"];
  v729  [label="1664:  final double x2  = x * x"];
  v730  [label="1665:  final double f = 1.0 / (1 + x2)"];
  v731  [label="1666:  double coeff = FastMath.sqrt(f)"];
  v732  [label="1667:  function[1] = coeff * p[0]"];
  v733  [label="1668:  for (  int n = 2 ; n <= order ;   ++n)"];
  v736  [label="endfor"];
  v737  [label="1671:  double v = 0"];
  v738  [label="1672:  p[n - 1] = (1 - n) * p[n - 2]"];
  v739  [label="1673:  for (  int k = n - 1 ; k >= 0 ;   k -= 2)"];
  v742  [label="endfor"];
  v743  [label="1674:  v = v * x2 + p[k]"];
  v744  [label="1675:  if (k > 2)"];
  v745  [label="1676:  p[k - 2] = (k - 1) * p[k - 1] + (k - 2 * n) * p[k - 3]"];
  v746  [label="endif"];
  v747  [label="1677:  if (k == 2)"];
  v748  [label="1678:  p[0] = p[1]"];
  v749  [label="endif"];
  v750  [label="1681:  if ((n & 0x1) == 0)"];
  v751  [label="1682:  v *= x"];
  v752  [label="endif"];
  v753  [label="1685:  coeff *= f"];
  v754  [label="1686:  function[n] = coeff * v"];
  v755  [label="endif"];
  v756  [label="1692:  compose(operand, operandOffset, function, result, resultOffset)"];
  v757  [label="1704:  void atanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset)"];
  v758  [label="1708:  double[] function = new double[1 + order]"];
  v759  [label="1709:  final double x = operand[operandOffset]"];
  v760  [label="1710:  function[0] = FastMath.atanh(x)"];
  v761  [label="1711:  if (order > 0)"];
  v762  [label="1719:  final double[] q = new double[order]"];
  v763  [label="1720:  q[0] = 1"];
  v764  [label="1721:  final double x2 = x * x"];
  v765  [label="1722:  final double f  = 1.0 / (1 - x2)"];
  v766  [label="1723:  double coeff = f"];
  v767  [label="1724:  function[1] = coeff * q[0]"];
  v768  [label="1725:  for (  int n = 2 ; n <= order ;   ++n)"];
  v771  [label="endfor"];
  v772  [label="1728:  double v = 0"];
  v773  [label="1729:  q[n - 1] = n * q[n - 2]"];
  v774  [label="1730:  for (  int k = n - 1 ; k >= 0 ;   k -= 2)"];
  v777  [label="endfor"];
  v778  [label="1731:  v = v * x2 + q[k]"];
  v779  [label="1732:  if (k > 2)"];
  v780  [label="1733:  q[k - 2] = (k - 1) * q[k - 1] + (2 * n - k + 1) * q[k - 3]"];
  v781  [label="endif"];
  v782  [label="1734:  if (k == 2)"];
  v783  [label="1735:  q[0] = q[1]"];
  v784  [label="endif"];
  v785  [label="1738:  if ((n & 0x1) == 0)"];
  v786  [label="1739:  v *= x"];
  v787  [label="endif"];
  v788  [label="1742:  coeff *= f"];
  v789  [label="1743:  function[n] = coeff * v"];
  v790  [label="endif"];
  v791  [label="1749:  compose(operand, operandOffset, function, result, resultOffset)"];
  v792  [label="1763:  void compose(final double[] operand, final int operandOffset, final double[] f, final double[] result, final int resultOffset)"];
  v793  [label="1765:  for (  int i = 0 ; i < compIndirection.length ;   ++i)"];
  v796  [label="endfor"];
  v797  [label="1766:  final int[][] mappingI = compIndirection[i]"];
  v798  [label="1767:  double r = 0"];
  v799  [label="1768:  for (  int j = 0 ; j < mappingI.length ;   ++j)"];
  v802  [label="endfor"];
  v803  [label="1769:  final int[] mappingIJ = mappingI[j]"];
  v804  [label="1770:  double product = mappingIJ[0] * f[mappingIJ[1]]"];
  v805  [label="1771:  for (  int k = 2 ; k < mappingIJ.length ;   ++k)"];
  v808  [label="endfor"];
  v809  [label="1772:  product *= operand[operandOffset + mappingIJ[k]]"];
  v810  [label="1774:  r += product"];
  v811  [label="1776:  result[resultOffset + i] = r"];
  v812  [label="1787:  double taylor(final double[] ds, final int dsOffset, final double ... delta)"];
  v813  [label="1789:  double value = 0"];
  v814  [label="1790:  for (  int i = getSize( ;   --i) - 1 ; i >= 0 ;   --i)"];
  v817  [label="endfor"];
  v818  [label="1791:  final int[] orders = getPartialDerivativeOrders(i)"];
  v819  [label="1792:  double term = ds[dsOffset + i]"];
  v820  [label="1793:  for (  int k = 0 ; k < orders.length ;   ++k)"];
  v823  [label="endfor"];
  v824  [label="1794:  if (orders[k] > 0)"];
  v825  [label="1795:  try"];
  v826  [label="end-try"];
  v827  [label="1796:  term *= FastMath.pow(delta[k], orders[k]) / CombinatoricsUtils.factorial(orders[k])"];
  v828  [label="end-catch"];
  v829  [label="1798:  catch (NotPositiveException e)"];
  v830  [label="1800:  throw new MathInternalError(e)"];
  v831  [label="endif"];
  v832  [label="1804:  value += term"];
  v833  [label="1806:  return value;"];
  v834  [label="1813:  void checkCompatibility(final DSCompiler compiler)"];
  v835  [label="1815:  if (parameters != compiler.parameters)"];
  v836  [label="1816:  throw new DimensionMismatchException(parameters, compiler.parameters)"];
  v837  [label="endif"];
  v838  [label="1818:  if (order != compiler.order)"];
  v839  [label="1819:  throw new DimensionMismatchException(order, compiler.order)"];
  v840  [label="endif"];
  // graph-edges
  v1 -> v2;
  v2 -> v3;
  v3 -> v4;
  v4 -> v5;
  v5 -> v6;
  v6 -> v7;
  v7 -> v8;
  v9 -> v10;
  v10 -> v11;
  v11 -> v12  [label="True"];
  v11 -> v13  [label="False"];
  v13 -> v14;
  v14 -> v15;
  v15 -> v16;
  v16 -> v17;
  v17 -> v18  [label="True"];
  v18 -> v21  [label="False"];
  v18 -> v22  [label="True"];
  v22 -> v18;
  v21 -> v23;
  v17 -> v23  [label="False"];
  v23 -> v24;
  v24 -> v27  [label="False"];
  v24 -> v28  [label="True"];
  v28 -> v31  [label="False"];
  v28 -> v32  [label="True"];
  v32 -> v33;
  v33 -> v34  [label="True"];
  v34 -> v35;
  v35 -> v36;
  v36 -> v37;
  v33 -> v37  [label="False"];
  v37 -> v28;
  v31 -> v24;
  v27 -> v38;
  v38 -> v39;
  v40 -> v41;
  v41 -> v42;
  v42 -> v43  [label="True"];
  v43 -> v44;
  v42 -> v45  [label="False"];
  v45 -> v46;
  v46 -> v47;
  v47 -> v50  [label="False"];
  v47 -> v51  [label="True"];
  v51 -> v47;
  v50 -> v44;
  v44 -> v52;
  v53 -> v54;
  v54 -> v55  [label="True"];
  v54 -> v56  [label="False"];
  v56 -> v57;
  v57 -> v58;
  v58 -> v59;
  v59 -> v60;
  v60 -> v63  [label="False"];
  v60 -> v64  [label="True"];
  v64 -> v60;
  v63 -> v65;
  v65 -> v68  [label="False"];
  v65 -> v69  [label="True"];
  v69 -> v70;
  v70 -> v65;
  v68 -> v71;
  v72 -> v73;
  v73 -> v74  [label="True"];
  v73 -> v75  [label="False"];
  v75 -> v76;
  v76 -> v77;
  v77 -> v78;
  v78 -> v79;
  v79 -> v80;
  v80 -> v83  [label="False"];
  v80 -> v84  [label="True"];
  v84 -> v80;
  v83 -> v85;
  v86 -> v87;
  v87 -> v88  [label="True"];
  v87 -> v89  [label="False"];
  v89 -> v90;
  v90 -> v91;
  v91 -> v92;
  v92 -> v93;
  v93 -> v94;
  v94 -> v97  [label="False"];
  v94 -> v98  [label="True"];
  v98 -> v99;
  v99 -> v100;
  v100 -> v103  [label="False"];
  v100 -> v104  [label="True"];
  v104 -> v105;
  v105 -> v100;
  v103 -> v106;
  v106 -> v107;
  v107 -> v110  [label="False"];
  v107 -> v111  [label="True"];
  v111 -> v112;
  v112 -> v113  [label="True"];
  v113 -> v116  [label="False"];
  v113 -> v117  [label="True"];
  v117 -> v118;
  v118 -> v119  [label="True"];
  v119 -> v120;
  v120 -> v121;
  v118 -> v121  [label="False"];
  v121 -> v113;
  v116 -> v122;
  v122 -> v123;
  v112 -> v123  [label="False"];
  v123 -> v107;
  v110 -> v124;
  v124 -> v94;
  v97 -> v125;
  v126 -> v127;
  v127 -> v128  [label="True"];
  v127 -> v129  [label="False"];
  v129 -> v130;
  v130 -> v131;
  v131 -> v132;
  v132 -> v133;
  v133 -> v134;
  v134 -> v137  [label="False"];
  v134 -> v138  [label="True"];
  v138 -> v139;
  v139 -> v140  [label="False"];
  v139 -> v141  [label="True"];
  v141 -> v142;
  v142 -> v143;
  v143 -> v144;
  v144 -> v145;
  v145 -> v146;
  v146 -> v147;
  v147 -> v150  [label="False"];
  v147 -> v151  [label="True"];
  v151 -> v147;
  v150 -> v152;
  v152 -> v153;
  v153 -> v154;
  v154 -> v157  [label="False"];
  v154 -> v158  [label="True"];
  v158 -> v159;
  v159 -> v160;
  v160 -> v161;
  v161 -> v164  [label="False"];
  v161 -> v165  [label="True"];
  v165 -> v166;
  v166 -> v167  [label="True"];
  v167 -> v168;
  v168 -> v169;
  v169 -> v170;
  v166 -> v170  [label="False"];
  v170 -> v161;
  v164 -> v171;
  v171 -> v172;
  v172 -> v154;
  v157 -> v139;
  v140 -> v173;
  v173 -> v174;
  v174 -> v177  [label="False"];
  v174 -> v178  [label="True"];
  v178 -> v179;
  v179 -> v180  [label="True"];
  v180 -> v183  [label="False"];
  v180 -> v184  [label="True"];
  v184 -> v185;
  v185 -> v186;
  v186 -> v189  [label="False"];
  v186 -> v180  [label="True"];
  v180 -> v186;
  v189 -> v180;
  v180 -> v180  [label="True"];
  v180 -> v183;
  v183 -> v184;
  v180 -> v184  [label="False"];
  v184 -> v180;
  v183 -> v185;
  v179 -> v186  [label="False"];
  v186 -> v174;
  v177 -> v186;
  v186 -> v134;
  v137 -> v186;
  v180 -> v180  [label="False"];
  v186 -> v189;
  v189 -> v211  [label="False"];
  v189 -> v212  [label="True"];
  v212 -> v213;
  v213 -> v214;
  v214 -> v215  [label="True"];
  v214 -> v216  [label="False"];
  v216 -> v217;
  v217 -> v218  [label="False"];
  v217 -> v219  [label="True"];
  v219 -> v217;
  v218 -> v208;
  v208 -> v189;
  v211 -> v220;
  v221 -> v222;
  v222 -> v223;
  v223 -> v224;
  v225 -> v226;
  v227 -> v228;
  v229 -> v230;
  v231 -> v232;
  v233 -> v234;
  v234 -> v237  [label="False"];
  v234 -> v238  [label="True"];
  v238 -> v234;
  v239 -> v240;
  v240 -> v243  [label="False"];
  v240 -> v244  [label="True"];
  v244 -> v240;
  v245 -> v246;
  v246 -> v249  [label="False"];
  v246 -> v240  [label="True"];
  v240 -> v246;
  v240 -> v243;
  v243 -> v245  [label="False"];
  v243 -> v246  [label="True"];
  v246 -> v244;
  v244 -> v243;
  v246 -> v249;
  v249 -> v240  [label="False"];
  v249 -> v240  [label="True"];
  v240 -> v249;
  v243 -> v244;
  v244 -> v245;
  v245 -> v246  [label="False"];
  v245 -> v246  [label="True"];
  v249 -> v270;
  v270 -> v273  [label="False"];
  v270 -> v274  [label="True"];
  v274 -> v270;
  v273 -> v275;
  v275 -> v246;
  v246 -> v245;
  v276 -> v277;
  v277 -> v278;
  v278 -> v279;
  v280 -> v281;
  v281 -> v282;
  v282 -> v283;
  v283 -> v284;
  v284 -> v287  [label="False"];
  v284 -> v288  [label="True"];
  v288 -> v284;
  v289 -> v280;
  v281 -> v282  [label="True"];
  v282 -> v283  [label="True"];
  v284 -> v288  [label="False"];
  v284 -> v289  [label="True"];
  v280 -> v287;
  v287 -> v284;
  v288 -> v281;
  v282 -> v282  [label="False"];
  v282 -> v284  [label="False"];
  v284 -> v281;
  v281 -> v284;
  v281 -> v284  [label="False"];
  v284 -> v287;
  v287 -> v288;
  v288 -> v289;
  v289 -> v311  [label="False"];
  v289 -> v312  [label="True"];
  v312 -> v308;
  v308 -> v289;
  v311 -> v284;
  v284 -> v313;
  v314 -> v315;
  v315 -> v316;
  v316 -> v317;
  v317 -> v320  [label="False"];
  v317 -> v321  [label="True"];
  v321 -> v322;
  v322 -> v317;
  v320 -> v323;
  v323 -> v324;
  v324 -> v325;
  v325 -> v328  [label="False"];
  v325 -> v329  [label="True"];
  v329 -> v330;
  v330 -> v325;
  v328 -> v331;
  v332 -> v333;
  v333 -> v334  [label="True"];
  v334 -> v335;
  v335 -> v336;
  v333 -> v337  [label="False"];
  v337 -> v338;
  v338 -> v339;
  v339 -> v340  [label="True"];
  v340 -> v341;
  v341 -> v342;
  v342 -> v345  [label="False"];
  v342 -> v346  [label="True"];
  v346 -> v347;
  v347 -> v342;
  v345 -> v348;
  v348 -> v349;
  v339 -> v350  [label="False"];
  v350 -> v351;
  v351 -> v352;
  v352 -> v355  [label="False"];
  v352 -> v356  [label="True"];
  v356 -> v357;
  v357 -> v352;
  v355 -> v349;
  v349 -> v358;
  v358 -> v359;
  v359 -> v362  [label="False"];
  v359 -> v363  [label="True"];
  v363 -> v364;
  v364 -> v359;
  v362 -> v365;
  v366 -> v367;
  v367 -> v368;
  v368 -> v369;
  v369 -> v370;
  v370 -> v371;
  v372 -> v373;
  v373 -> v374;
  v374 -> v375;
  v375 -> v376  [label="True"];
  v376 -> v377;
  v377 -> v378;
  v375 -> v379  [label="False"];
  v379 -> v380  [label="True"];
  v380 -> v381;
  v381 -> v382;
  v379 -> v383  [label="False"];
  v383 -> v384;
  v384 -> v382;
  v382 -> v378;
  v378 -> v385;
  v385 -> v386;
  v386 -> v387;
  v387 -> v390  [label="False"];
  v387 -> v391  [label="True"];
  v391 -> v392;
  v392 -> v387;
  v390 -> v393;
  v394 -> v395;
  v395 -> v396;
  v396 -> v397;
  v398 -> v399;
  v399 -> v400;
  v400 -> v401;
  v401 -> v402;
  v403 -> v404;
  v404 -> v405;
  v405 -> v406;
  v406 -> v407  [label="True"];
  v407 -> v408;
  v408 -> v409;
  v409 -> v412  [label="False"];
  v409 -> v413  [label="True"];
  v413 -> v414;
  v414 -> v409;
  v412 -> v415;
  v406 -> v415  [label="False"];
  v415 -> v416;
  v417 -> v418;
  v418 -> v419;
  v419 -> v420;
  v420 -> v421  [label="True"];
  v421 -> v422;
  v422 -> v423;
  v423 -> v426  [label="False"];
  v423 -> v427  [label="True"];
  v427 -> v428;
  v428 -> v423;
  v426 -> v429;
  v420 -> v429  [label="False"];
  v429 -> v430;
  v431 -> v432;
  v432 -> v433;
  v433 -> v434;
  v434 -> v435  [label="True"];
  v435 -> v436;
  v436 -> v437;
  v437 -> v440  [label="False"];
  v437 -> v441  [label="True"];
  v441 -> v442;
  v442 -> v437;
  v440 -> v443;
  v434 -> v443  [label="False"];
  v443 -> v444;
  v445 -> v446;
  v446 -> v447;
  v447 -> v448;
  v448 -> v449  [label="True"];
  v449 -> v450;
  v450 -> v453  [label="False"];
  v450 -> v454  [label="True"];
  v454 -> v450;
  v453 -> v455;
  v448 -> v455  [label="False"];
  v455 -> v456;
  v457 -> v458;
  v458 -> v459;
  v459 -> v460;
  v460 -> v461  [label="True"];
  v461 -> v462;
  v462 -> v465  [label="False"];
  v462 -> v466  [label="True"];
  v466 -> v462;
  v465 -> v467;
  v460 -> v467  [label="False"];
  v467 -> v468;
  v469 -> v470;
  v470 -> v471;
  v471 -> v472;
  v472 -> v473;
  v473 -> v474  [label="True"];
  v474 -> v475;
  v475 -> v476;
  v476 -> v477;
  v477 -> v470  [label="False"];
  v477 -> v471  [label="True"];
  v473 -> v474;
  v474 -> v476  [label="False"];
  v474 -> v477  [label="True"];
  v477 -> v477  [label="True"];
  v477 -> v470;
  v477 -> v471  [label="False"];
  v471 -> v472  [label="True"];
  v471 -> v473  [label="False"];
  v473 -> v470;
  v470 -> v475;
  v475 -> v474;
  v476 -> v474;
  v474 -> v475  [label="True"];
  v470 -> v477;
  v473 -> v477  [label="False"];
  v500 -> v501;
  v501 -> v502;
  v502 -> v503;
  v503 -> v504;
  v504 -> v505  [label="True"];
  v505 -> v506;
  v506 -> v507;
  v507 -> v508;
  v508 -> v509;
  v509 -> v510;
  v510 -> v511;
  v511 -> v514  [label="False"];
  v511 -> v515  [label="True"];
  v515 -> v516;
  v516 -> v517;
  v517 -> v520  [label="False"];
  v517 -> v521  [label="True"];
  v521 -> v522;
  v522 -> v523  [label="True"];
  v523 -> v524;
  v522 -> v525  [label="False"];
  v525 -> v526  [label="True"];
  v526 -> v527;
  v525 -> v527  [label="False"];
  v527 -> v524;
  v524 -> v517;
  v520 -> v528;
  v528 -> v529  [label="True"];
  v529 -> v530;
  v528 -> v530  [label="False"];
  v530 -> v531;
  v531 -> v532;
  v532 -> v511;
  v514 -> v533;
  v504 -> v533  [label="False"];
  v533 -> v534;
  v535 -> v536;
  v536 -> v537;
  v537 -> v538;
  v538 -> v539;
  v539 -> v540  [label="True"];
  v540 -> v541;
  v541 -> v542;
  v542 -> v543;
  v543 -> v544;
  v544 -> v545;
  v545 -> v546;
  v546 -> v549  [label="False"];
  v546 -> v550  [label="True"];
  v550 -> v551;
  v551 -> v552;
  v552 -> v555  [label="False"];
  v552 -> v556  [label="True"];
  v556 -> v557;
  v557 -> v558  [label="True"];
  v558 -> v559;
  v557 -> v560  [label="False"];
  v560 -> v561  [label="True"];
  v561 -> v562;
  v560 -> v562  [label="False"];
  v562 -> v559;
  v559 -> v552;
  v555 -> v563;
  v563 -> v564  [label="True"];
  v564 -> v565;
  v563 -> v565  [label="False"];
  v565 -> v566;
  v566 -> v567;
  v567 -> v546;
  v549 -> v568;
  v539 -> v568  [label="False"];
  v568 -> v569;
  v570 -> v571;
  v571 -> v572;
  v572 -> v573;
  v573 -> v574;
  v574 -> v575  [label="True"];
  v575 -> v576;
  v576 -> v577;
  v577 -> v578;
  v578 -> v579;
  v579 -> v580;
  v580 -> v581;
  v581 -> v584  [label="False"];
  v581 -> v585  [label="True"];
  v585 -> v586;
  v586 -> v587;
  v587 -> v590  [label="False"];
  v587 -> v591  [label="True"];
  v591 -> v592;
  v592 -> v593  [label="True"];
  v593 -> v594;
  v592 -> v595  [label="False"];
  v595 -> v596  [label="True"];
  v596 -> v597;
  v595 -> v597  [label="False"];
  v597 -> v594;
  v594 -> v587;
  v590 -> v598;
  v598 -> v599  [label="True"];
  v599 -> v600;
  v598 -> v600  [label="False"];
  v600 -> v601;
  v601 -> v602;
  v602 -> v581;
  v584 -> v603;
  v574 -> v603  [label="False"];
  v603 -> v604;
  v605 -> v606;
  v606 -> v607;
  v607 -> v608;
  v608 -> v609;
  v609 -> v600;
  v602 -> v603  [label="True"];
  v604 -> v605;
  v607 -> v609  [label="False"];
  v607 -> v600  [label="True"];
  v600 -> v608;
  v608 -> v607;
  v609 -> v601;
  v602 -> v602  [label="False"];
  v602 -> v603;
  v607 -> v630  [label="True"];
  v630 -> v608;
  v601 -> v631;
  v632 -> v633;
  v633 -> v634;
  v634 -> v635;
  v635 -> v636  [label="True"];
  v636 -> v637;
  v637 -> v640  [label="False"];
  v637 -> v641  [label="True"];
  v641 -> v637;
  v640 -> v642;
  v635 -> v642  [label="False"];
  v642 -> v643;
  v644 -> v645;
  v645 -> v646;
  v646 -> v647;
  v647 -> v648  [label="True"];
  v648 -> v649;
  v649 -> v652  [label="False"];
  v649 -> v653  [label="True"];
  v653 -> v649;
  v652 -> v654;
  v647 -> v654  [label="False"];
  v654 -> v655;
  v656 -> v657;
  v657 -> v658;
  v658 -> v659;
  v659 -> v649;
  v649 -> v649  [label="True"];
  v649 -> v652;
  v652 -> v653;
  v653 -> v654;
  v655 -> v657  [label="False"];
  v655 -> v658  [label="True"];
  v649 -> v653  [label="False"];
  v649 -> v654  [label="True"];
  v655 -> v656  [label="True"];
  v655 -> v658  [label="False"];
  v658 -> v659  [label="True"];
  v659 -> v680;
  v658 -> v680  [label="False"];
  v680 -> v657;
  v657 -> v652;
  v652 -> v649;
  v653 -> v681;
  v681 -> v682  [label="True"];
  v682 -> v683;
  v681 -> v683  [label="False"];
  v683 -> v684;
  v684 -> v656;
  v656 -> v655;
  v657 -> v685;
  v649 -> v685  [label="False"];
  v685 -> v686;
  v687 -> v688;
  v688 -> v689;
  v689 -> v690;
  v690 -> v691;
  v691 -> v692  [label="True"];
  v692 -> v693;
  v693 -> v694;
  v694 -> v695;
  v695 -> v696;
  v696 -> v697;
  v697 -> v698;
  v698 -> v701  [label="False"];
  v698 -> v702  [label="True"];
  v702 -> v703;
  v703 -> v704;
  v704 -> v707  [label="False"];
  v704 -> v708  [label="True"];
  v708 -> v709;
  v709 -> v710  [label="True"];
  v710 -> v711;
  v709 -> v712  [label="False"];
  v712 -> v713  [label="True"];
  v713 -> v714;
  v712 -> v714  [label="False"];
  v714 -> v711;
  v711 -> v704;
  v707 -> v715;
  v715 -> v716  [label="True"];
  v716 -> v717;
  v715 -> v717  [label="False"];
  v717 -> v718;
  v718 -> v719;
  v719 -> v698;
  v701 -> v720;
  v691 -> v720  [label="False"];
  v720 -> v721;
  v722 -> v723;
  v723 -> v724;
  v724 -> v725;
  v725 -> v726;
  v726 -> v727  [label="True"];
  v727 -> v728;
  v728 -> v729;
  v729 -> v730;
  v730 -> v731;
  v731 -> v732;
  v732 -> v733;
  v733 -> v736  [label="False"];
  v733 -> v737  [label="True"];
  v737 -> v738;
  v738 -> v739;
  v739 -> v742  [label="False"];
  v739 -> v743  [label="True"];
  v743 -> v744;
  v744 -> v745  [label="True"];
  v745 -> v746;
  v744 -> v747  [label="False"];
  v747 -> v748  [label="True"];
  v748 -> v749;
  v747 -> v749  [label="False"];
  v749 -> v746;
  v746 -> v739;
  v742 -> v750;
  v750 -> v751  [label="True"];
  v751 -> v752;
  v750 -> v752  [label="False"];
  v752 -> v753;
  v753 -> v754;
  v754 -> v733;
  v736 -> v755;
  v726 -> v755  [label="False"];
  v755 -> v756;
  v757 -> v758;
  v758 -> v759;
  v759 -> v760;
  v760 -> v761;
  v761 -> v762  [label="True"];
  v762 -> v763;
  v763 -> v764;
  v764 -> v765;
  v765 -> v766;
  v766 -> v767;
  v767 -> v768;
  v768 -> v771  [label="False"];
  v768 -> v772  [label="True"];
  v772 -> v773;
  v773 -> v774;
  v774 -> v777  [label="False"];
  v774 -> v778  [label="True"];
  v778 -> v779;
  v779 -> v780  [label="True"];
  v780 -> v781;
  v779 -> v782  [label="False"];
  v782 -> v783  [label="True"];
  v783 -> v784;
  v782 -> v784  [label="False"];
  v784 -> v781;
  v781 -> v774;
  v777 -> v785;
  v785 -> v786  [label="True"];
  v786 -> v787;
  v785 -> v787  [label="False"];
  v787 -> v788;
  v788 -> v789;
  v789 -> v768;
  v771 -> v790;
  v761 -> v790  [label="False"];
  v790 -> v791;
  v792 -> v793;
  v793 -> v796  [label="False"];
  v793 -> v797  [label="True"];
  v797 -> v798;
  v798 -> v799;
  v799 -> v802  [label="False"];
  v799 -> v803  [label="True"];
  v803 -> v804;
  v804 -> v805;
  v805 -> v808  [label="False"];
  v805 -> v809  [label="True"];
  v809 -> v805;
  v808 -> v799;
  v802 -> v799;
  v799 -> v793;
  v802 -> v803;
  v805 -> v805  [label="False"];
  v805 -> v808  [label="True"];
  v808 -> v809;
  v809 -> v799;
  v799 -> v803  [label="False"];
  v799 -> v804  [label="True"];
  v804 -> v805  [label="True"];
  v805 -> v809  [label="Throws"];
  v809 -> v830;
  v830 -> v805  [label="Throws"];
  v808 -> v805;
  v805 -> v831;
  v804 -> v831  [label="False"];
  v831 -> v802;
  v803 -> v832;
  v832 -> v805;
  v805 -> v833;
  v834 -> v835;
  v835 -> v836  [label="True"];
  v835 -> v837  [label="False"];
  v837 -> v838;
  v838 -> v839  [label="True"];
  v838 -> v840  [label="False"];
  // end-of-graph
}
