digraph TDistribution_CFG {
  // graph-vertices
  v1  [label="53:  TDistribution (double degreesOfFreedom)"];
  v2  [label="55:  this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY)"];
  v3  [label="69:  TDistribution (double degreesOfFreedom, double inverseCumAccuracy)"];
  v4  [label="71:  this(new Well19937c(), degreesOfFreedom, inverseCumAccuracy)"];
  v5  [label="82:  TDistribution (RandomGenerator rng, double degreesOfFreedom)"];
  v6  [label="84:  this(rng, degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY)"];
  v7  [label="98:  TDistribution (RandomGenerator rng,  double degreesOfFreedom,  double inverseCumAccuracy)"];
  v8  [label="102:  super(rng)"];
  v9  [label="104:  if (degreesOfFreedom <= 0)"];
  v10  [label="105:  throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,  degreesOfFreedom)"];
  v11  [label="endif"];
  v12  [label="108:  this.degreesOfFreedom = degreesOfFreedom"];
  v13  [label="109:  solverAbsoluteAccuracy = inverseCumAccuracy"];
  v14  [label="117:  double getDegreesOfFreedom()"];
  v15  [label="118:  return degreesOfFreedom;"];
  v16  [label="122:  double density(double x)"];
  v17  [label="123:  final double n = degreesOfFreedom"];
  v18  [label="124:  final double nPlus1Over2 = (n + 1) / 2"];
  v19  [label="125:  return FastMath.exp(Gamma.logGamma(nPlus1Over2) - 0.5 * (FastMath.log(FastMath.PI) +  FastMath.log(n)) - Gamma.logGamma(n / 2) - nPlus1Over2 * FastMath.log(1 + x * x / n));"];
  v20  [label="133:  double cumulativeProbability(double x)"];
  v21  [label="134:  double ret"];
  v22  [label="135:  if (x == 0)"];
  v23  [label="136:  ret = 0.5"];
  v24  [label="endif"];
  v25  [label="138:  double t = Beta.regularizedBeta( degreesOfFreedom / (degreesOfFreedom + (x * x)), 0.5 * degreesOfFreedom, 0.5)"];
  v26  [label="143:  if (x < 0.0)"];
  v27  [label="144:  ret = 0.5 * t"];
  v28  [label="endif"];
  v29  [label="146:  ret = 1.0 - 0.5 * t"];
  v30  [label="150:  return ret;"];
  v31  [label="155:  double getSolverAbsoluteAccuracy()"];
  v32  [label="156:  return solverAbsoluteAccuracy;"];
  v33  [label="168:  double getNumericalMean()"];
  v34  [label="169:  final double df = getDegreesOfFreedom()"];
  v35  [label="171:  if (df > 1)"];
  v36  [label="172:  return 0;"];
  v37  [label="endif"];
  v38  [label="175:  return Double.NaN;"];
  v39  [label="189:  double getNumericalVariance()"];
  v40  [label="190:  final double df = getDegreesOfFreedom()"];
  v41  [label="192:  if (df > 2)"];
  v42  [label="193:  return df / (df - 2);"];
  v43  [label="endif"];
  v44  [label="196:  if (df > 1 && df <= 2)"];
  v45  [label="197:  return Double.POSITIVE_INFINITY;"];
  v46  [label="endif"];
  v47  [label="200:  return Double.NaN;"];
  v48  [label="212:  double getSupportLowerBound()"];
  v49  [label="213:  return Double.NEGATIVE_INFINITY;"];
  v50  [label="225:  double getSupportUpperBound()"];
  v51  [label="226:  return Double.POSITIVE_INFINITY;"];
  v52  [label="230:  boolean isSupportLowerBoundInclusive()"];
  v53  [label="231:  return false;"];
  v54  [label="235:  boolean isSupportUpperBoundInclusive()"];
  v55  [label="236:  return false;"];
  v56  [label="246:  boolean isSupportConnected()"];
  v57  [label="247:  return true;"];
  // graph-edges
  v1 -> v2;
  v3 -> v4;
  v5 -> v6;
  v7 -> v8;
  v8 -> v9;
  v9 -> v10  [label="True"];
  v9 -> v11  [label="False"];
  v11 -> v12;
  v12 -> v13;
  v14 -> v15;
  v16 -> v17;
  v17 -> v18;
  v18 -> v19;
  v20 -> v21;
  v21 -> v22;
  v22 -> v23  [label="True"];
  v23 -> v24;
  v22 -> v25  [label="False"];
  v25 -> v26;
  v26 -> v27  [label="True"];
  v27 -> v28;
  v26 -> v29  [label="False"];
  v29 -> v28;
  v28 -> v24;
  v24 -> v30;
  v31 -> v32;
  v33 -> v34;
  v34 -> v35;
  v35 -> v36  [label="True"];
  v35 -> v37  [label="False"];
  v37 -> v38;
  v39 -> v40;
  v40 -> v41;
  v41 -> v42  [label="True"];
  v41 -> v43  [label="False"];
  v43 -> v44;
  v44 -> v45  [label="True"];
  v44 -> v46  [label="False"];
  v46 -> v47;
  v48 -> v49;
  v50 -> v51;
  v52 -> v53;
  v54 -> v55;
  v56 -> v57;
  // end-of-graph
}
